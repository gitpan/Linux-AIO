NAME
    Linux::AIO - linux-specific aio implemented using clone

SYNOPSIS
     use Linux::AIO;

DESCRIPTION
    This module implements asynchronous i/o using the means available to
    linux - clone. It does not hook into the POSIX aio_* functions because
    linux does not yet support these in the kernel (and even if, it would
    only allow aio_read and write, not open and stat).

    Instead, in this module a number of (non-posix) threads are started that
    execute your read/writes and signal their completion. You don't need
    thread support in your libc or perl, and the threads created by this
    module will not be visible to the pthreads library.

    Linux::AIO::min_parallel $nthreads
        Set the minimum number of AIO threads to $nthreads. You *have* to
        call this function with a positive number at least once, otherwise
        no threads will be started and you aio-operations will seem to hang.

        It is recommended to keep the number of threads low, as many linux
        kernel versions will scale negatively with the number of threads
        (higher parallelity => MUCH higher latency).

    $fileno = Linux::AIO::poll_fileno
        Return the *request result pipe filehandle*. This filehandle must be
        polled for reading by some mechanism outside this module (e.g. Event
        or select, see below). If the pipe becomes readable you have to call
        "poll_cb" to check the results.

    Linux::AIO::poll_cb
        Process all outstanding events on the result pipe. You have to call
        this regularly. Returns the number of events processed. Returns
        immediately when no events are outstanding.

        You can use Event to multiplex, e.g.:

           Event->io (fd => Linux::AIO::poll_fileno,
                      poll => 'r', async => 1,
                      cb => \&Linux::AIO::poll_cb );

    Linux::AIO::nreqs
        Returns the number of requests currently outstanding.

    aio_open $pathname, $flags, $mode, $callback
        Asynchronously open or create a file and call the callback with the
        filedescriptor (NOT a perl filehandle, sorry for that, but watch
        out, this might change in the future).

    aio_close $fh, $callback
        Asynchronously close a file and call the callback with the result
        code.

    aio_read $fh,$offset,$length, $data,$dataoffset,$callback
    aio_write $fh,$offset,$length, $data,$dataoffset,$callback
        Reads or writes "length" bytes from the specified "fh" and "offset"
        into the scalar given by "data" and offset "dataoffset" and calls
        the callback without the actual number of bytes read (or "undef" on
        error).

    aio_stat $fh_or_path, $callback
    aio_lstat $fh, $callback
        Works like perl's "stat" or "lstat" in void context. The callback
        will be called after the stat and the results will be available
        using "stat _" or "-s _" etc...

        Currently, the stats are always 64-bit-stats, i.e. instead of
        returning an error when stat'ing a large file, the results will be
        silently truncated unless perl itself is compiled with large file
        support.

BUGS
    This module has been extensively tested in a large and very busy
    webserver for many years now.

       - aio_open gives a fd, but all other functions expect a perl filehandle.

SEE ALSO
    Coro.

AUTHOR
     Marc Lehmann <pcg@goof.com>
     http://www.goof.com/pcg/marc/

